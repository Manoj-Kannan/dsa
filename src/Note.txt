Introduction:
Abstract Data Type  - interface         =   What are the expected behaviour from the user point of view
                                        -   (e.g. queue needs enque & deque mechanisms)
Data Structures     - implementation    -   How the behaviours are exhibited
                                        -   (e.g. queue can be implemented ny use of list)

Note:
Arrays      -   index based
            -   predefined size (allocates sections within the memory)
            -   ideal for item retrieval (if index is known)

LinkedList  -   reference based
            -   dynamic size
            -   ideal for insertion & deletion

Doubly LinkedList   -   variation of LinkedList, where each element points to both the next & previous item
                    -   can be easily traversed in forward & reverse direction
                    -   adding or removing element from a DLL is more efficient than LL (since we need not keep track of previod node separately)
                    -   extra memory is need (since we store the previous node also)

Stack       -   Abstract Data Type
            -   implemented using Array / Linked List
            -   follows Last-In-First-Out Mechanism (LIFO)
            -   Useful in Memory Management (Stack Memory), recursion, Undo Mechanism

Queue       -   Abstract Data Type
            -   implemented using Array / Linked List
            -   follows First-In-First-Out Mechanism (FIFO)
            -   Useful in CPU task Scheduling, BFS

Map         -   Abstract Data Type
            -   Mostly implemented using HashTables (contains slot for storing data)
            -   or can be implemented using Trees
            -   Hashing (hashes a key to an index) (elements can be retrieved using same hash (O(1) TimeComplexity))
            -   Collision - A new key is put into the map where the map already contains the same key.
                -   Chaining:
                    -   Both the elements are stored in LinkedList (one after the other) at same hash index.
                    -   When we try to retrieve the value for the key, we need to iterate through the LL. (becomes O(N) TimeComplexity)
                -   Open-Addressing:
                    -   Makes use of Probing mechanism to avoid collision (searches for an empty slot)
                    -   Linear Probing
                    -   Quadratic Probing
                    -   Double Probing
                -   Finally,
                    -   In Chaining Mechanism, item will be stored somewhere in the Array (find by hash)/ somewhere in the ArrayList (loop over the LL)
                    -   In Probing, only one item sill be present in a index (find only by hash)
